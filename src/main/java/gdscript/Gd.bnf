{
  parserClass="gdscript.parser.GdParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Gd"
  psiImplClassSuffix="Impl"
  psiPackage="gdscript.psi"
  psiImplPackage="gdscript.psi.impl"

  elementTypeHolderClass="gdscript.psi.GdTypes"
  elementTypeClass="gdscript.psi.GdElementType"
  tokenTypeClass="gdscript.psi.GdTokenType"

  psiImplUtilClass="gdscript.psi.GdPsiUtils"

  mixin(".*_nm")="GdNamedElementImpl"
  implements(".*_nm")="GdNamedElement"
  methods(".*_nm")=[getName setName]

  mixin(".*_nmi")="GdNamedIdElementImpl"
  implements(".*_nmi")="GdNamedIdElement"
  methods(".*_nmi")=[getName setName getNameIdentifier]

  extends(".*_tl")=topLevelDecl
  extends(".*_ex")=expr
  extends(".*_st")=stmt

  consumeTokenMethod(".*_ex|expr|stmt|.*_st|topLevelDecl|.*_tl")="consumeTokenFast"

  tokens = [
    string='regexp:"[^"]*?"'
    number='regexp:[0-9]+(\.)?[0-9]*'
    comment='regexp:#.*'
    bad_character='regexp:[\^]'
  ]
}

gdfile ::= inheritance? classNaming? toolline? topLevelDecl*

inheritance ::= EXTENDS inheritanceId_nmi (DOT IDENTIFIER)? newLineEnd {methods=[getInheritanceName] pin=1 recoverWhile=inheritance_r mixin="gdscript.psi.impl.GdInheritanceElementImpl" stubClass="gdscript.index.stub.GdInheritanceStub" elementTypeFactory="gdscript.psi.impl.GdInheritanceElementType.getInstance"}
inheritanceId_nmi ::= IDENTIFIER
private inheritance_r ::= !(CLASS_NAME | TOOL) & topLevelDecl_r

// TODO ."resource"
classNaming ::= CLASS_NAME className_nm (COMMA STRING)? newLineEnd {methods=[getClassname getParentName] pin=1 recoverWhile=classNaming_r mixin="gdscript.psi.impl.GdClassNamingElementImpl" stubClass="gdscript.index.stub.GdClassNamingStub" elementTypeFactory="gdscript.psi.impl.GdClassNamingElementType.getInstance"}
className_nm ::= IDENTIFIER
private classNaming_r ::= !(TOOL) & topLevelDecl_r

toolline ::= TOOL newLineEnd {pin=1 recoverWhile=topLevelDecl_r}

topLevelDecl ::=
    constDecl_tl
    | classVarDecl_tl
    | methodDecl_tl
//    | enumDecl_tl
    | signalDecl_tl

private topLevelDecl_r ::= !(FUNC | CONST | SIGNAL | VAR | annotation)

constDecl_tl ::= CONST constId_nmi typed? EQ expr endStmt {methods=[getConstName getReturnType getPresentation] pin=1 recoverWhile=topLevelDecl_r mixin="gdscript.psi.impl.GdConstDeclElementImpl" stubClass="gdscript.index.stub.GdConstDeclStub" elementTypeFactory="gdscript.psi.impl.GdConstDeclElementType.getInstance"}
constId_nmi ::= IDENTIFIER

classVarDecl_tl ::= annotation* VAR classVarId_nmi typed? (EQ expr)? setgetDecl? endStmt {methods=[getName getReturnType getPresentation] pin=2 recoverWhile=topLevelDecl_r  mixin="gdscript.psi.impl.GdClassVarDeclElementImpl" stubClass="gdscript.index.stub.GdClassVarDeclStub" elementTypeFactory="gdscript.psi.impl.GdClassVarDeclElementType.getInstance"}
classVarId_nmi ::= IDENTIFIER
setgetDecl ::= SETGET setMethodId_nm? (COMMA getMethodId_nm)?
setMethodId_nm ::= IDENTIFIER
getMethodId_nm ::= IDENTIFIER

signalDecl_tl ::= SIGNAL signalId_nmi signalParList? endStmt {methods=[getName getParameters] pin=1 recoverWhile=topLevelDecl_r mixin="gdscript.psi.impl.GdSignalDeclElementImpl" stubClass="gdscript.index.stub.GdSignalDeclStub" elementTypeFactory="gdscript.psi.impl.GdSignalDeclElementType.getInstance"}
signalParList ::= LRBR IDENTIFIER (COMMA IDENTIFIER)* RRBR
signalId_nmi ::= IDENTIFIER

// TODO
//enum {UNIT_NEUTRAL, UNIT_ENEMY, UNIT_ALLY}
//enum Named {THING_1, THING_2, ANOTHER_THING = -1}

//enumDecl_tl ::= ENUM enumId_nmi "{" [ IDENTIFIER [ "=" INTEGER ]
//    { "," IDENTIFIER [ "=" INTEGER ] } [ "," ] ] "}" NEWLINE ;
//enumId_nmi ::= IDENTIFIER

// TODO recover nesmí mít func -> inline lambdy by to porušily
methodDecl_tl ::= FUNC methodId_nmi LRBR paramList? RRBR parentMethodCall? returnHint? COLON stmtOrSuite {methods=[getName getReturnType getParameters getPresentation isConstructor] pin=1 recoverWhile=topLevelDecl_r mixin="gdscript.psi.impl.GdMethodDeclElementImpl" stubClass="gdscript.index.stub.GdMethodDeclStub" elementTypeFactory="gdscript.psi.impl.GdMethodDeclElementType.getInstance"}
methodId_nmi ::= IDENTIFIER
paramList ::= param (COMMA param)*
param ::= VAR? var_nmi typed? (EQ expr)?
returnHint ::= RET returnHintVal
returnHintVal ::= typeHint_nm | VOID
parentMethodCall ::= DOT LRBR argList? RRBR
argList ::= expr (COMMA expr)*

var_nmi ::= IDENTIFIER

// TODO inner class

stmtOrSuite ::= stmt | suite
suite ::= NEW_LINE INDENT stmt+ DEDENT {pin=3}

stmt ::=
    assign_st
    | varDecl_st
    | if_st
    | while_st
    | for_st
    | match_st
    | expr_st
    | flow_st
    | assert_st
    | yield_st
    | preload_st

varDecl_st ::= VAR var_nmi typed? (EQ expr)? endStmt
if_st ::= IF expr COLON stmtOrSuite (ELIF expr COLON stmtOrSuite)* (ELSE COLON stmtOrSuite)?
while_st ::= WHILE expr COLON stmtOrSuite
for_st ::= FOR var_nmi IN expr COLON stmtOrSuite

match_st ::= MATCH //expression ":" NEWLINE INDENT matchBlock DEDENT;
//matchBlock = patternList ":" stmtOrSuite { patternList ":" stmtOrSuite };
//patternList = pattern { "," pattern } ;
//(* Note: you can't have a binding in a pattern list, but to not complicate the
//grammar more it won't be restricted syntactically *)
//pattern = literal | BUILTINTYPE | CONSTANT | "_" | bindingPattern
//    | arrayPattern | dictPattern ;
//bindingPattern = "var" IDENTIFIER ;
//arrayPattern = "[" [ pattern { "," pattern } [ ".." ] ] "]" ;
//dictPattern = "{" [ keyValuePattern ] { "," keyValuePattern } [ ".." ] "}" ;
//keyValuePattern = STRING [ ":" pattern ] ;

assert_st ::= ASSERT LRBR expr (COMMA STRING)? RRBR endStmt
yield_st ::= YIELD LRBR (expr COMMA expr)? RRBR
preload_st ::= PRELOAD LRBR STRING RRBR // TODO resource

assign_st ::= expr (EQ | ASSIGN) expr endStmt
expr_st ::= expr endStmt {pin=1}

flow_st ::=
    (CONTINUE endStmt)
    | (BREAK endStmt)
    | (PASS endStmt)
    | (BREAKPOINT endStmt)
    | returnStmt
returnStmt ::= RETURN expr? endStmt

expr ::=
    plusMinus_ex
    | cast_ex
    | ternary_ex
    | logic_ex
    | negate_ex
    | in_ex
    | comparison_ex
    | bitAnd_ex
    | shift_ex
    | plus_ex
    | factor_ex
    | sign_ex
    | bitNot_ex
    | plusMinusPre_ex
    | attribute_ex
    | is_ex
    | call_ex
    | arr_ex
    | primary_ex
    | literal_ex
    {methods=[getReturnType]}

cast_ex ::= expr AS typeHint_nm
ternary_ex ::= expr IF expr ELSE expr
logic_ex ::= expr (ANDAND | OROR) expr
negate_ex ::= NEGATE expr;
in_ex ::= expr IN expr
comparison_ex ::= expr TEST_OPERATOR expr
bitAnd_ex ::= expr (AND | XOR | OR) expr
shift_ex ::= expr (LBSHIFT | RBSHIFT) expr
plus_ex ::= expr (PLUS | MINUS) expr
factor_ex ::= expr (MUL | DIV | MOD) expr
sign_ex ::= (MINUS | PLUS ) expr
bitNot_ex ::= NOT expr
is_ex ::= expr IS typeHint_nm
call_ex ::= expr LRBR argList? RRBR
arr_ex ::= expr LSBR expr RSBR
primary_ex ::= nodePath | arrayDecl | dictDecl | (LRBR expr RRBR)
literal_ex ::= TRUE | FALSE | STRING | NUMBER | NULL | PI | TAU | NAN | INF | refId_nm

//@"Node/Label"
//NodePath or StringName

//$NodePath
//Shorthand for get_node("NodePath")

plusMinus_ex ::= expr (PPLUS | MMINUS)
plusMinusPre_ex ::= (PPLUS | MMINUS) expr
attribute_ex ::= expr DOT attEx_nm //TODO
attEx_nm ::= IDENTIFIER
refId_nm ::= IDENTIFIER | SELF

typed ::= COLON typeHint_nm
typeHint_nm ::= builtInType | IDENTIFIER
builtInType ::= INT | STR | FLOAT | BOOL
endStmt ::= SEMICON | newLineEnd
newLineEnd ::= NEW_LINE | <<eof>>
annotation ::= ANNOTATOR // TODO params
nodePath ::= NODE_PATH_LEX

arrayDecl ::= LSBR (expr (COMMA expr)* COMMA?)? RSBR
dictDecl ::= LCBR (keyValue (COMMA keyValue)* COMMA?)? RCBR
keyValue ::= (expr COLON expr) | (IDENTIFIER EQ expr)