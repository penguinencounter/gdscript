{
  parserClass="gdscript.parser.GdParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Gd"
  psiImplClassSuffix="Impl"
  psiPackage="gdscript.psi"
  psiImplPackage="gdscript.psi.impl"

  elementTypeHolderClass="gdscript.psi.GdTypes"
  elementTypeClass="gdscript.psi.GdElementType"
  tokenTypeClass="gdscript.psi.GdTokenType"

  psiImplUtilClass="gdscript.psi.GdPsiUtils"

  mixin(".*_nm")="GdNamedElementImpl"
  implements(".*_nm")="GdNamedElement"
  methods(".*_nm")=[getName setName]

  mixin(".*_nmi")="GdNamedIdElementImpl"
  implements(".*_nmi")="GdNamedIdElement"
  methods(".*_nmi")=[getName setName getNameIdentifier]

  extends(".*_tl")=topLevelDecl
  extends(".*_ex")=expr
  extends(".*_st")=stmt

  consumeTokenMethod(".*_ex|expr|stmt|.*_st|topLevelDecl|.*_tl")="consumeTokenFast"

  tokens = [
    string='regexp:"[^"]*?"'
    number='regexp:[0-9]+(\.)?[0-9]*'
    comment='regexp:#.*'
    bad_character='regexp:[\^]'
  ]
}

gdfile ::= inheritance? classNaming?  topLevelDecl*

inheritance ::= EXTENDS inheritanceId_nmi (DOT IDENTIFIER)? newLineEnd {methods=[getInheritanceName] pin=1 recoverWhile=inheritance_r mixin="gdscript.psi.impl.GdInheritanceElementImpl" stubClass="gdscript.index.stub.GdInheritanceStub" elementTypeFactory="gdscript.psi.impl.GdInheritanceElementType.getInstance"}
inheritanceId_nmi ::= IDENTIFIER
private inheritance_r ::= !(CLASS_NAME | TOOL) & topLevelDecl_r

classNaming ::= CLASS_NAME className_nm (COMMA STRING)? newLineEnd {methods=[getClassname getParentName] pin=1 recoverWhile=classNaming_r mixin="gdscript.psi.impl.GdClassNamingElementImpl" stubClass="gdscript.index.stub.GdClassNamingStub" elementTypeFactory="gdscript.psi.impl.GdClassNamingElementType.getInstance"}
className_nm ::= IDENTIFIER
private classNaming_r ::= !(TOOL) & topLevelDecl_r

topLevelDecl ::=
    constDecl_tl
    | methodDecl_tl
    | enumDecl_tl
    | signalDecl_tl
    | classVarDecl_tl
    | annotation_tl
private topLevelDecl_r ::= !(FUNC | CONST | SIGNAL | VAR | ENUM | ANNOTATOR)

constDecl_tl ::= CONST constId_nmi typed? EQ expr endStmt {methods=[getConstName getReturnType getPresentation] pin=1 recoverWhile=topLevelDecl_r mixin="gdscript.psi.impl.GdConstDeclElementImpl" stubClass="gdscript.index.stub.GdConstDeclStub" elementTypeFactory="gdscript.psi.impl.GdConstDeclElementType.getInstance"}
constId_nmi ::= IDENTIFIER

annotation_tl ::= annotation (LRBR literal_ex (COMMA literal_ex)* RRBR)? {pin=1 recoverWhile=topLevelDecl_r}
classVarDecl_tl ::= VAR classVarId_nmi typed? (EQ expr)? setgetDecl? endStmt {methods=[getName getReturnType getPresentation] pin=1 recoverWhile=topLevelDecl_r  mixin="gdscript.psi.impl.GdClassVarDeclElementImpl" stubClass="gdscript.index.stub.GdClassVarDeclStub" elementTypeFactory="gdscript.psi.impl.GdClassVarDeclElementType.getInstance"}
classVarId_nmi ::= IDENTIFIER
setgetDecl ::= SETGET setMethodId_nm? (COMMA getMethodId_nm)?
setMethodId_nm ::= IDENTIFIER
getMethodId_nm ::= IDENTIFIER

signalDecl_tl ::= SIGNAL signalId_nmi signalParList? endStmt {methods=[getName getParameters] pin=1 recoverWhile=topLevelDecl_r mixin="gdscript.psi.impl.GdSignalDeclElementImpl" stubClass="gdscript.index.stub.GdSignalDeclStub" elementTypeFactory="gdscript.psi.impl.GdSignalDeclElementType.getInstance"}
signalParList ::= LRBR IDENTIFIER (COMMA IDENTIFIER)* RRBR
signalId_nmi ::= IDENTIFIER

enumDecl_tl ::= ENUM enumDecl_nmi? LCBR enumValue ((COMMA | NEW_LINE) enumValue)* (COMMA | NEW_LINE)? RCBR endStmt {pin=1 methods=[getValues getPresentation] recoverWhile=topLevelDecl_r mixin="gdscript.psi.impl.GdEnumDeclElementImpl" stubClass="gdscript.index.stub.GdEnumDeclStub" elementTypeFactory="gdscript.psi.impl.GdEnumDeclElementType.getInstance"}
enumDecl_nmi ::= IDENTIFIER
enumValue ::= enumValue_nmi (EQ (PLUS | MINUS)? NUMBER)?
enumValue_nmi ::= IDENTIFIER

// TODO recover nesmí mít func -> inline lambdy by to porušily
methodDecl_tl ::= FUNC methodId_nmi LRBR paramList? RRBR parentMethodCall? returnHint? COLON stmtOrSuite {methods=[getName getReturnType getParameters getPresentation isConstructor] pin=1 recoverWhile=topLevelDecl_r mixin="gdscript.psi.impl.GdMethodDeclElementImpl" stubClass="gdscript.index.stub.GdMethodDeclStub" elementTypeFactory="gdscript.psi.impl.GdMethodDeclElementType.getInstance"}
methodId_nmi ::= IDENTIFIER
paramList ::= param (COMMA param)*
param ::= VAR? var_nmi typed? (EQ expr)?
returnHint ::= RET returnHintVal
returnHintVal ::= typeHint_nm | VOID
parentMethodCall ::= DOT LRBR argList? RRBR
argList ::= expr (COMMA expr)*

var_nmi ::= IDENTIFIER

// TODO inner class

stmtOrSuite ::= stmt | suite
suite ::= NEW_LINE INDENT stmt+ DEDENT {pin=3}

stmt ::=
    assign_st
    | varDecl_st
    | constDecl_st
    | if_st
    | while_st
    | for_st
    | match_st
    | expr_st
    | flow_st
    | assert_st
    | await_st
    | preload_st

varDecl_st ::= VAR var_nmi typed? (EQ expr)? endStmt
constDecl_st ::= CONST var_nmi typed? (EQ expr)? endStmt
if_st ::= IF expr COLON stmtOrSuite (ELIF expr COLON stmtOrSuite)* (ELSE COLON stmtOrSuite)?
while_st ::= WHILE expr COLON stmtOrSuite
for_st ::= FOR var_nmi IN expr COLON stmtOrSuite

match_st ::= MATCH //expression ":" NEWLINE INDENT matchBlock DEDENT;
//matchBlock = patternList ":" stmtOrSuite { patternList ":" stmtOrSuite };
//patternList = pattern { "," pattern } ;
//(* Note: you can't have a binding in a pattern list, but to not complicate the
//grammar more it won't be restricted syntactically *)
//pattern = literal | BUILTINTYPE | CONSTANT | "_" | bindingPattern
//    | arrayPattern | dictPattern ;
//bindingPattern = "var" IDENTIFIER ;
//arrayPattern = "[" [ pattern { "," pattern } [ ".." ] ] "]" ;
//dictPattern = "{" [ keyValuePattern ] { "," keyValuePattern } [ ".." ] "}" ;
//keyValuePattern = STRING [ ":" pattern ] ;

assert_st ::= ASSERT LRBR expr (COMMA STRING)? RRBR endStmt
await_st ::= AWAIT LRBR (expr COMMA expr)? RRBR // TODO
preload_st ::= PRELOAD LRBR STRING RRBR // TODO resource

assign_st ::= expr (EQ | ASSIGN) expr endStmt
expr_st ::= expr endStmt {pin=1}

flow_st ::=
    (CONTINUE endStmt)
    | (BREAK endStmt)
    | (PASS endStmt)
    | (BREAKPOINT endStmt)
    | returnStmt
returnStmt ::= RETURN expr? endStmt

expr ::=
    plusMinus_ex
    | cast_ex
    | ternary_ex
    | logic_ex
    | negate_ex
    | in_ex
    | comparison_ex
    | bitAnd_ex
    | shift_ex
    | plus_ex
    | factor_ex
    | sign_ex
    | bitNot_ex
    | plusMinusPre_ex
    | attribute_ex
    | is_ex
    | call_ex
    | arr_ex
    | primary_ex
    | literal_ex
    {methods=[getReturnType]}

cast_ex ::= expr AS typeHint_nm
ternary_ex ::= expr IF expr ELSE expr
logic_ex ::= expr (ANDAND | OROR) expr
negate_ex ::= NEGATE expr;
in_ex ::= expr IN expr
comparison_ex ::= expr TEST_OPERATOR expr
bitAnd_ex ::= expr (AND | XOR | OR) expr
shift_ex ::= expr (LBSHIFT | RBSHIFT) expr
plus_ex ::= expr (PLUS | MINUS) expr
factor_ex ::= expr (MUL | DIV | MOD) expr
sign_ex ::= (MINUS | PLUS ) expr
bitNot_ex ::= NOT expr
is_ex ::= expr IS typeHint_nm
call_ex ::= expr LRBR argList? RRBR
arr_ex ::= expr LSBR expr RSBR
primary_ex ::= nodePath | arrayDecl | dictDecl | (LRBR expr RRBR)
literal_ex ::= TRUE | FALSE | STRING | NUMBER | NULL | PI | TAU | NAN | INF | refId_nm

//@"Node/Label"
//NodePath or StringName

//$NodePath
//Shorthand for get_node("NodePath")

plusMinus_ex ::= expr (PPLUS | MMINUS)
plusMinusPre_ex ::= (PPLUS | MMINUS) expr
attribute_ex ::= expr DOT attEx_nm //TODO
attEx_nm ::= IDENTIFIER
refId_nm ::= IDENTIFIER | SELF

typed ::= COLON typeHint_nm
typeHint_nm ::= builtInType | IDENTIFIER
builtInType ::= INT | STR | FLOAT | BOOL
endStmt ::= SEMICON | newLineEnd
newLineEnd ::= NEW_LINE | <<eof>>
nodePath ::= NODE_PATH_LEX
annotation ::= ANNOTATOR

arrayDecl ::= LSBR (expr (COMMA expr)* COMMA?)? RSBR
dictDecl ::= LCBR (keyValue (COMMA keyValue)* COMMA?)? RCBR
keyValue ::= (expr COLON expr) | (IDENTIFIER EQ expr)