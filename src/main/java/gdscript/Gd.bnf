{
  parserClass="gdscript.parser.GdParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Gd"
  psiImplClassSuffix="Impl"
  psiPackage="gdscript.psi"
  psiImplPackage="gdscript.psi.impl"

  elementTypeHolderClass="gdscript.psi.GdTypes"
  elementTypeClass="gdscript.psi.GdElementType"
  tokenTypeClass="gdscript.psi.GdTokenType"

  psiImplUtilClass="gdscript.psi.GdPsiUtils"

  mixin(".*_nm")="GdNamedElementImpl"
  implements(".*_nm")="GdNamedElement"
  methods(".*_nm")=[getName setName]

  mixin(".*_nmi")="GdNamedIdElementImpl"
  implements(".*_nmi")="GdNamedIdElement"
  methods(".*_nmi")=[getName setName getNameIdentifier]

  extends(".*_tl")=topLevelDecl
//  extends(".*Expression")=expr

  tokens = [
//    /* Keywords */
//    class='class'
//    class_name='class_name'
//    extends='extends'
//    tool='tool'
//    enum='enum'
//    self='self'
//    func='func'
//    const='const'
//    if='if'
//    else='else'
//    elif='elif'
//    var='var'
//    int='int'
//    true='true'
//    false='false'
//    null='null'
//    pass='pass'
//    setget='setget'
//    signal='signal'
//    static='static'
//    ret='->'
//    init='_init'
//    breakpoint='breakpoint'
//    while='while'
//    for='for'
//    in='in'
//    match='match'
//    under='_'
//    continue='continue'
//    break='break'
//    return='return'
//    assert='assert'
//    yield='yield'
//    preload='preload'
//    as='as'
//    and='and'
//    or='or'
//    not='not'
//    pi='PI'
//    tau='TAU'
//    nan='NAN'
//    inf='INF'
//
//    /* Annotations */
//    onready='@onready'
//    export='@export'
//
//    /* Syntax */
//    lcbr='{'
//    rcbr='}'
//    lrbr='('
//    rrbr=')'
//    lsbr='['
//    rsbr=']'
//    semicon=';'
//    comma=','
//    colon=':'
//    ternary='?'
//    dotdot='..'
//    dot='.'
//    eq='='
//
//    new_line='regexp:[\n\r]+'
//    identifier='regexp:[a-zA-Z_][a-zA-Z_0-9]*'
    string='regexp:"[^"]*?"'
    number='regexp:[0-9]+(\.)?[0-9]*'
    comment='regexp:#.*'
//    space='regexp:\s+'
    bad_character='regexp:[\^]'
  ]
}

gdfile ::= inheritance? classNaming? toolline? topLevelDecl*

inheritance ::= EXTENDS inheritanceId_nmi (DOT IDENTIFIER)? newLineEnd {methods=[getInheritanceName] pin=1 recoverWhile=inheritance_r mixin="gdscript.psi.impl.GdInheritanceElementImpl" stubClass="gdscript.index.stub.GdInheritanceStub" elementTypeFactory="gdscript.psi.impl.GdInheritanceElementType.getInstance"}
inheritanceId_nmi ::= IDENTIFIER
private inheritance_r ::= !(CLASS_NAME | TOOL) & topLevelDecl_r

// TODO resource
classNaming ::= CLASS_NAME className_nm (COMMA STRING)? newLineEnd {methods=[getClassname getParentName] pin=1 recoverWhile=classNaming_r mixin="gdscript.psi.impl.GdClassNamingElementImpl" stubClass="gdscript.index.stub.GdClassNamingStub" elementTypeFactory="gdscript.psi.impl.GdClassNamingElementType.getInstance"}
className_nm ::= IDENTIFIER
private classNaming_r ::= !(TOOL) & topLevelDecl_r

toolline ::= TOOL newLineEnd {pin=1 recoverWhile=topLevelDecl_r}

topLevelDecl ::=
    constDecl_tl |
    classVarDecl_tl |
    methodDecl_tl

private topLevelDecl_r ::= !(FUNC | CONST | VAR | annotation)

constDecl_tl ::= CONST constId_nmi typed? EQ expr endStmt {methods=[getConstName getReturnType] pin=1 recoverWhile=topLevelDecl_r mixin="gdscript.psi.impl.GdConstDeclElementImpl" stubClass="gdscript.index.stub.GdConstDeclStub" elementTypeFactory="gdscript.psi.impl.GdConstDeclElementType.getInstance"}
constId_nmi ::= IDENTIFIER

classVarDecl_tl ::= annotation* VAR classVarId_nmi typed? (EQ expr)? setgetDecl? endStmt {methods=[getVarName getReturnType] pin=2 recoverWhile=topLevelDecl_r  mixin="gdscript.psi.impl.GdClassVarDeclElementImpl" stubClass="gdscript.index.stub.GdClassVarDeclStub" elementTypeFactory="gdscript.psi.impl.GdClassVarDeclElementType.getInstance"}
classVarId_nmi ::= IDENTIFIER
setgetDecl ::= SETGET setMethodId_nm? (COMMA getMethodId_nm)?
setMethodId_nm ::= IDENTIFIER
getMethodId_nm ::= IDENTIFIER

// TODO recover nesmí mít func -> inline lambdy by to porušily
methodDecl_tl ::= FUNC methodId_nmi LRBR paramList? RRBR returnHint? COLON stmtOrSuite {methods=[getMethodName getReturnType getParameters] pin=1 recoverWhile=topLevelDecl_r mixin="gdscript.psi.impl.GdMethodDeclElementImpl" stubClass="gdscript.index.stub.GdMethodDeclStub" elementTypeFactory="gdscript.psi.impl.GdMethodDeclElementType.getInstance"}
methodId_nmi ::= IDENTIFIER
paramList ::= param (COMMA param)*
param ::= VAR? IDENTIFIER typed? (EQ expr)?
returnHint ::= RET (typeHint_nm | VOID)

stmtOrSuite ::= stmt | (NEW_LINE INDENT suite DEDENT?)
suite ::= stmt*

stmt ::=
    PASS endStmt |
    CONTINUE | BREAK | RETURN | SELF // TODO

expr ::=
    literal

typed ::= COLON typeHint_nm
typeHint_nm ::= builtInType | IDENTIFIER
literal ::= TRUE | FALSE | STRING | NUMBER | NULL
builtInType ::= INT | STR
endStmt ::= SEMICON | newLineEnd
newLineEnd ::= NEW_LINE | <<eof>>
annotation ::= ANNOTATOR // TODO params
