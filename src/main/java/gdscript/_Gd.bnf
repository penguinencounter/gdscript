{
  parserClass="gdscript.parser.GdParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Gd"
  psiImplClassSuffix="Impl"
  psiPackage="gdscript.psi"
  psiImplPackage="gdscript.psi.impl"

  elementTypeHolderClass="gdscript.psi.GdTypes"
  elementTypeClass="gdscript.psi.GdElementType"
  tokenTypeClass="gdscript.psi.GdTokenType"

  psiImplUtilClass="gdscript.psi.GdPsiUtils"

  extends(".*Expression")=expr
  extends(".*_TL")=topLevelDecl

  tokens = [
    /* Keywords */
    class='class'
    class_name='class_name'
    extends='extends'
    tool='tool'
    enum='enum'
    self='self'
    func='func'
    const='const'
    if='if'
    else='else'
    elif='elif'
    var='var'
    int='int'
    true='true'
    false='false'
    null='null'
    pass='pass'
    setget='setget'
    signal='signal'
    static='static'
    ret='->'
    init='_init'
    breakpoint='breakpoint'
    while='while'
    for='for'
    in='in'
    match='match'
    under='_'
    continue='continue'
    break='break'
    return='return'
    assert='assert'
    yield='yield'
    preload='preload'
    as='as'
    and='and'
    or='or'
    not='not'
    pi='PI'
    tau='TAU'
    nan='NAN'
    inf='INF'

    /* Annotations */
    onready='@onready'
    export='@export'

    /* Syntax */
    lcbr='{'
    rcbr='}'
    lrbr='('
    rrbr=')'
    lsbr='['
    rsbr=']'
    semicon=';'
    comma=','
    colon=':'
    ternary='?'
    dotdot='..'
    dot='.'
    eq='='

    new_line='regexp:[\n\r]+'
    identifier='regexp:[a-zA-Z_][a-zA-Z_0-9]*'
    string='regexp:"[^"]*?"'
    number='regexp:[0-9]+(\.)?[0-9]*'
    comment='regexp:#.*'
    space='regexp:\s+'
    bad_character='regexp:[\^]'
  ]
}

gdfile ::= inheritance classNaming? (TOOL NEW_LINE)? topLevelDecl*

inheritance ::= EXTENDS IDENTIFIER (DOT IDENTIFIER)? NEW_LINE {methods=[getParentClassName] pin=1 recoverWhile=inheritance_r}
private inheritance_r ::= !(CLASS_NAME | TOOL | FUNC | annotation | CONST)

classNaming ::= CLASS_NAME IDENTIFIER (COMMA STRING)? NEW_LINE {methods=[getName] pin=1 recoverWhile=classNaming_r}
private classNaming_r ::= !(TOOL) & topLevelDecl_r

topLevelDecl ::=
    classVarDecl_TL
    | constDecl
    | signalDecl
    | enumDecl
    | methodDecl
    | constructorDecl
    | innerClass
private topLevelDecl_r ::= !(VAR | CONST | (STATIC? FUNC) | annotation | SIGNAL | ENUM | CLASS)

classVarDecl_TL ::= annotation* VAR IDENTIFIER typed? (EQ expr)? setgetDecl? endStmt {pin=2 recoverWhile=topLevelDecl_r}
setgetDecl ::= setget IDENTIFIER (COMMA IDENTIFIER)?

// TODO below unfinished
constDecl ::= CONST IDENTIFIER typed? EQ expr endStmt

signalDecl ::= SIGNAL IDENTIFIER signalParamList endStmt
signalParamList ::= LRBR IDENTIFIER (COMMA IDENTIFIER)* RRBR

enumDecl ::= ENUM IDENTIFIER LCBR enumDeclValue (enumDeclValue)* RCBR endStmt
enumDeclValue ::= IDENTIFIER (EQ NUMBER)? COMMA?

// TODO annotations viz gdscript 2.0
methodDecl ::= STATIC? FUNC IDENTIFIER LRBR paramList? RRBR returnHint? COLON stmtOrSuite methodDecl {methods=[getMethodName]}
paramList ::= param (COMMA param)*
param ::= VAR? IDENTIFIER typed? (EQ expr)?
returnHint ::= RET typeHint

constructorDecl ::= FUNC INIT LCBR paramList? RCBR (DOT LRBR argList? RRBR)? returnHint?
argList ::= expr (COMMA expr)*

innerClass ::= CLASS IDENTIFIER inheritance? COLON /*NEW_LINE*/ /*indent*/ topLevelDecl+ /*dedent*/

stmtOrSuite ::= stmt | (/*NEW_LINE*/ /*indent*/ suite /*dedent*/)* // TODO bez *
suite ::= stmt*

stmt ::=
    varDeclStmt
    | ifStmt
    | forStmt
    | whileStmt
    | matchStmt
    | flowStmt
//    | assignmentStmt
    | assertStmt
    | yieldStmt
    | preloadStmt

    | BREAKPOINT endStmt
    | PASS endStmt
    | exprStmt


ifStmt ::= IF expr COLON stmtOrSuite (ELIF expr COLON stmtOrSuite)* (ELSE COLON stmtOrSuite)?
whileStmt ::= WHILE expr COLON stmtOrSuite
forStmt ::= FOR IDENTIFIER IN expr COLON stmtOrSuite

matchStmt ::= MATCH expr COLON /*NEW_LINE*/ /*indent*/ matchBlock /*dedent*/
matchBlock ::= patternList COLON stmtOrSuite (patternList COLON stmtOrSuite)*
patternList ::= pattern (COMMA pattern)*

// TODO Note: you can't have a binding in a pattern list, but to not complicate the
//grammar more it won't be restricted syntactically
pattern ::= literal | builtInType | /*TODO constant*/ UNDER | bindingPattern | arrayPattern | dictPattern
bindingPattern ::= VAR IDENTIFIER
arrayPattern ::= LSBR (pattern (COMMA pattern)* DOTDOT?)? RSBR ;
dictPattern ::= LCBR keyValuePattern? (COMMA keyValuePattern)* DOTDOT? RCBR
keyValuePattern ::= STRING (COLON pattern)?

flowStmt ::=
    CONTINUE endStmt
    | BREAK endStmt
    | RETURN expr? endStmt

//TODO assignmentStmt ::= subscription EQ expression endStmt
varDeclStmt ::= VAR IDENTIFIER (EQ expr)? endStmt

assertStmt ::= ASSERT LCBR expr (COMMA STRING)? RCBR endStmt
yieldStmt ::= YIELD LCBR (expr COMMA expr)? RCBR
preloadStmt ::= PRELOAD LCBR /*TODO constant*/ STRING RCBR

exprStmt ::= expr endStmt

expr ::=
    assignExpression
    | conditionalExpression
    | roundBracketExpression
    | computeExpression
    | testExpression
    | referenceExpression

    | plusMinusExpression
    | plusMinusRevExpression
    | literalExpression

assignExpression ::= expr ASSIGN (expr | lambda)expr
conditionalExpression ::= expr TERNARY expr COLON expr
roundBracketExpression ::=LRBR expr* RRBR
computeExpression ::= expr OPERATOR expr
plusMinusExpression ::= ("++"|"--") expr
plusMinusRevExpression ::= expr ("++"|"--")expr
referenceExpression ::= "!"? (IDENTIFIER | SELF) (DOT? ((LRBR argList? RRBR) | IDENTIFIER))?expr
testExpression ::= expr TEST_OPERATOR expr
literalExpression ::= "!"? literal
// TODO

// TODO lambda
lambda ::= "lbdn"

literal ::= STRING | NUMBER | IDENTIFIER | builtInType | PI | TAU | NAN | INF | SELF
//TODO arrayDecl ::= LSBR ( expression (COMMA expression)* )? RSBR
//dictDecl ::= LCBR ( keyValue (COMMA keyValue)* )? RCBR
//keyValue ::=
//    expr COLON expr
//    | IDENTIFIER EQ expr

// TODO className
typed ::= COLON typeHint
typeHint ::= builtInType | IDENTIFIER

// Syntax sugar
//TODO
//indent ::=
//dedent ::=
endStmt ::= SEMICON | NEW_LINE
builtInType ::= int
//constant ::=
annotation ::= (ONREADY | EXPORT) NEW_LINE?
